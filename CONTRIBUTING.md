## Guide for Developing Terraform Modules

This repository is based on the template for creating Terraform modules. Therefore, certain rules must be followed for its development.

### Requirements

- Prior knowledge of Terraform
- Prior knowledge of the provider to be used
- Must have Make
- Must have Docker

### Rules

- Activate the hooks by running "make git-config" or consider the following before each commit
  - Autogenerate the README.md file with terraform-docs
  - Format the code (terraform fmt)
  - Validate the terraform code
  - Run the terraform tests (terraform test)
  - All commits must follow the [Angular convention](https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit)

## Structure of the most important files

- **:file_folder:.githooks/** (*)  
  - **:page_facing_up:commit-msg** *(validates that the commit message follows the Angular convention)*
  - **:page_facing_up:pre-commit** *(formats the code and updates README.md + git add modified .{tf,md} files)*
- **:file_folder:invocation-examples/** *(Deployment examples)*
  - **:file_folder:basic/** *(organization example)*
  - **:file_folder:example-1/** *(organization example)*
  - **:file_folder:speficic-case/** *(organization example)*
  - **:page_facing_up:.gitkeep** *(to track the empty folder)*
- **:page_facing_up:.editorconfig** *(configuration to standardize styles in different editors)*
- **:page_facing_up:.gitignore** *(configuration to not track files with git)*
- **:page_facing_up:.terraform-docs.yml** *(configuration for [terraform-docs](https://terraform-docs.io/))*
- **:page_facing_up:CONTRIBUTING.md** *(rules for collaborating on the project)*
- **:page_facing_up:data.tf** *(information defined outside of Terraform -or in another module-)*
- **:page_facing_up:main.tf** *(configuration for the submodule)*
- **:page_facing_up:Makefile**  (**)
- **:page_facing_up:outputs.tf** *(definition for the module outputs-info-)*
- **:page_facing_up:README.md** *(submodule documentation autogenerated with terraform-docs)*
- **:page_facing_up:variables.tf** *(variable-argument definitions for your module)*
- **:page_facing_up:VERSION** *(module version -will be used to create the tag-)*
- **:page_facing_up:versions.tf** *(configuration of the terraform and provider version)*

### .githooks (*)

The hooks are configured assuming that Docker and Make are available. Therefore, aliases/shortcuts are found within the Makefile.

If Docker or Make is not available

- Install both terraform and terraform-docs on your host
- For hook activation:
  - Do not run git-config, init, or init-vscode
  - Refer to the files in .githooks and Makefile to implement the hooks within .git/hooks
  
### Makefile (**)
  
- **git-config**: Configures the hooks by setting the path in .githooks.

- **td-readme**: Runs terraform-docs to create/update README.md files.

- **tf-fmt**: Runs terraform fmt to format the code.

- **tf-init**: Initializes the Terraform configuration without a backend.

- **tf-validate**: Initializes and validates the Terraform code.

- **tf-test**: Execute "terraform test" without implications currently.

- **pre-commit**: Runs a series of commands before allowing a commit.

- **install-vscode-extensions**: Installs the recommended extensions for VSCode.

- **init**: Configures the necessary settings for the module.

- **init-vscode**: Runs init and installs VSCode extensions.

---

## Source-Control Branching Model (SCBM)

For the development of Terraform modules, we will base ourselves on [Trunk-Based Development (TBD)](https://trunkbaseddevelopment.com/).

We will have a single permanent branch called "main".

```mermaid
%%{init: { 'theme': 'base'} }%%
gitGraph
  commit id: "feature 1"
  commit id: "feature 2"
```

### Commit

Each time a new functionality is to be added, a new branch must be created from "main" and a PR must be requested. The GitHub rule "Require linear history" will be activated, so base yourself on one of the following strategies for the commit and respect the [Angular convention](https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit).

If you have the hooks active, the following will be triggered:

```mermaid
flowchart TB
  i1pc([Start pre-commit]) --> Bpc[Format the code]
  Bpc --> Cpc[Update README.md]
  Cpc --> Dpc[Validate .tf files]
  Dpc --> Epc[Terraform tests]
  Epc --> Fpc[git add .tf and .md files]
  Fpc --> i2pc([End])
  
  i1cm([Start commit-msg]) --> Bcm[Validate the commit message]
  Bcm --> Ccm{Message OK?}
  Ccm -->|No| Ecm[Error - exit 1] --> i2cm([End])
  Ccm -->|Yes| Dcm[commit] --> i2cm
```

**merge**

To apply merge, first update the feature branch with the new commits from "main". After resolving any conflicts, generate the commit.

**rebase**

To apply rebase, first update the master branch and then apply the rebase on the feature branch and resolve any conflicts.

```mermaid
flowchart TB
  i1([Start merge]) --> B[\git add ./]
  B --> C[\git stash/]
  C --> D[\git fetch/]
  D --> E[\git merge origin/main/]
  E --> F[\git stash apply/]
  F --> G{Are there conflicts?}
  G -->|No| H[\git commit -m message/]
  G -->|Yes| I[\resolve conflicts/]
  I --> J[\git add ./]
  J --> K[\git merge --continue/] --> H
  H --> L[\git stash drop/]
  L --> M[\git push origin feature/feature-4/]
  M --> i2([End])
  
  i1r([Start rebase]) --> Br[\git add ./]
  Br --> Cr[\git commit -m message/]
  Cr --> Dr[\git fetch/]
  Dr --> Er[\git rebase -i origin/main/]
  Er --> Fr{Are there conflicts?}
  Fr -->|No| Gr[\git push origin feature/feature-4/]
  Fr -->|Yes| Hr[\resolve conflicts/]
  Hr --> Ir[\git add ./]
  Ir --> Jr[\git rebase --continue/] --> Gr
  Gr --> i2r([End])
```

### Pull Request
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

Once the commit is generated, you can proceed to request a PR to "main". If the corresponding validations were satisfactory and the PR is accepted by someone from the CODEOWNERS, you can proceed with the merge.

**GitHub Workflow: pull-request.yml**

```mermaid
flowchart TB
  i1([Start PR Check]) --> B[\Request PR from GitHub/]
  B --> G[Commit convention validation]
  G --> H{commits OK?}
  H -->|No| F[Error state] --> i2([End])
  H -->|Yes| C((Code Validation))
  C --> D{Validation OK?}
  D --> |Yes| E[Success state] --> i2
  D -->|No| F
```

```mermaid
%%{init: { 'theme': 'base'} }%%
gitGraph
  commit id: "feature 1"
  commit id: "feature 2"
  commit id: "feature 3"
  branch feature/feature-4
  commit id: "feature 4"
  checkout main
  merge feature/feature-4
```

It will also be configured that all source branches are deleted after the PR merge

```mermaid
flowchart TB
  i1([Start merge to main]) --> B((PR Check))
  B --> C{PR check success?}
  C -->|No| E[No merge] -->i2
  C -->|Yes| D{Linear History?}
  D -->|No| E
  D -->|Yes| F[\Code Review/]
  F --> G{CR OK?}
  G -->|No| E
  G -->|Yes| H[merge] --> i2([End])
```

```mermaid
%%{init: { 'theme': 'base'} }%%
gitGraph
  commit id: "feature 1"
  commit id: "feature 2"
  commit id: "feature 3"
  commit id: "feature 4"
```

### Release

To generate a release, run the GitHub Workflow "Create Release" (release.yml). This will generate the tag and release on GitHub.

**GitHub Workflow: release.yml**

```mermaid
flowchart TB
  i1([Start]) --> B[\Run the release workflow/]
  B --> C{Is the GitHub Actor a member of the Credicorp?}
  C -->|No| I[Skipped state] --> i2([End])
  C -->|Yes| D[Get version for Tag from VERSION]
  D --> E{Does the Tag exist?}
  E -->|Yes| J[Error state] --> i2
  E -->|No| F[Create Tag]
  F --> G[Push Tag] 
  G --> H[Create GitHub Release]
  H --> K[Success state] --> i2
```

```mermaid
%%{init: { 'theme': 'base'} }%%
gitGraph
  commit id: "feature 1"
  commit id: "feature 2"
  commit id: "feature 3"
  commit id: "feature 4" tag: "v1.0.0"
```

### New Release

The workflow will remain linear and continue towards the new version, maintaining the established rules and working on it.

```mermaid
%%{init: { 'theme': 'base'} }%%
gitGraph
  commit id: "feature 1"
  commit id: "feature 2"
  commit id: "feature 3"
  commit id: "feature 4" tag: "v1.0.0"
  commit id: "feature 5"
  branch feature/feature-6
  commit id: "feature 6"
  checkout main
  merge feature/feature-6
  commit id: "feature 7" tag: "v1.0.1"
```

## Rules
>
> **Here all the rules related to the repository will be explained**.

### Repository Configuration

- Activate the GitHub rules "Require linear history" and "Delete head branches"
- No one can bypass PR or any GitHub rule
- No one can delete tags
- Protected tags must have the nomenclature `v*, v1*, etc`
  - All release tags will be protected
- Only GitHub Host Runners are used

### Branch Protection

- A PR is required before merging to "main"
- PRs need at least 1 validations
- It will only proceed with merging to "main" if the PR has a "success" status check
- The branch must be up to date before being merged
- The "main" branch does not allow "force pushes"
- Only the CODEOWNERS can review PRs

---

## Step-by-step of the GitHub Workflows with each tool used

### Pull Request

This workflow, called "Pull Request Check", is automatically triggered
when a Pull Request is opened towards the master branch in the repository. The main purpose
is to execute verification and validation processes before merging changes into the main branch.

```mermaid
flowchart LR
    i1([Start PR Check]) --> B[Git Config]
    B --> C[Checkout]
    C --> D[Convention Validation Commits]
    D --> E[Setup Terraform]
    E --> F[Terraform Fmt]
    F --> G[Terraform Init]
    G --> H[Terraform Validate]
    H --> I[Terraform Test]
    I --> J[Tfsec GitHub Action]
    J --> K[Upload SARIF file]
    K --> M[Validate Documentation]
    M --> L[End]
```

### New Release

This GitHub Actions workflow is designed to automate the process of creating a new tag and release on GitHub.

```mermaid
flowchart LR
  i1([Start]) --> B[Checkout]
  B --> C[Get Tag Version]
  C --> D[Create Tag]
  D --> E[Release]
  E --> F[Create Major Version Tag]
  F --> G[End]
```
